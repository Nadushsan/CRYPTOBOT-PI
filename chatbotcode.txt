cat > crypto_pro_complete.py << 'EOF'
#!/usr/bin/env python3
"""
üîê CRYPTOBOT PRO COMPLETE
Tous les algorithmes : Vigen√®re, C√©sar, Enigma, AES, ChaCha20, RSA, SHA-256
"""

import base64
import json
import hashlib
from Crypto.Cipher import AES, ChaCha20
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2, scrypt
from Crypto.Util.Padding import pad, unpad

class CryptoBotPro:
    def __init__(self):
        print("\n" + "="*60)
        print("üîê CRYPTOBOT PRO - TOUS LES ALGORITHMES")
        print("="*60)
        print("Vigen√®re | C√©sar | Enigma | AES | ChaCha20 | RSA | SHA-256")
        print("="*60)
        
        self.rsa_keys = {}
    
    # ====================================================
    # üèõÔ∏è ALGORITHMES CLASSIQUES
    # ====================================================
    
    def vigenere(self, text, key, mode='encrypt'):
        """Vigen√®re"""
        key = key.upper().replace(' ', '')
        result = []
        key_index = 0
        
        for char in text:
            if char.isalpha():
                is_upper = char.isupper()
                char_upper = char.upper()
                
                key_char = key[key_index % len(key)]
                shift = ord(key_char) - ord('A')
                
                if mode == 'decrypt':
                    shift = -shift
                
                new_char = chr((ord(char_upper) - ord('A') + shift) % 26 + ord('A'))
                
                if not is_upper:
                    new_char = new_char.lower()
                
                result.append(new_char)
                key_index += 1
            else:
                result.append(char)
        
        return ''.join(result)
    
    def caesar(self, text, shift, mode='encrypt'):
        """C√©sar"""
        if mode == 'decrypt':
            shift = -shift
        
        result = []
        for char in text:
            if char.isalpha():
                is_upper = char.isupper()
                base = ord('A') if is_upper else ord('a')
                new_char = chr((ord(char) - base + shift) % 26 + base)
                result.append(new_char)
            else:
                result.append(char)
        
        return ''.join(result)
    
    def enigma(self, text, rotors=['I', 'II', 'III'], reflector='B', position='AAA'):
        """Enigma Machine (simplifi√©e)"""
        # Rotors historiques
        rotor_wirings = {
            'I':    'EKMFLGDQVZNTOWYHXUSPAIBRCJ',
            'II':   'AJDKSIRUXBLHWTMCQGZNPYFVOE',
            'III':  'BDFHJLCPRTXVZNYEIWGAKMUSQO',
            'IV':   'ESOVPZJAYQUIRHXLNFTGKDCMWB',
            'V':    'VZBRGITYUPSDNHLXAWMJQOFECK'
        }
        
        reflectors = {
            'B': 'YRUHQSLDPXNGOKMIEBFZCWVJAT',
            'C': 'FVPJIAOYEDRZXWGCTKUQSBNMHL'
        }
        
        result = []
        rotor_pos = [ord(c) - ord('A') for c in position]
        
        for char in text.upper():
            if 'A' <= char <= 'Z':
                idx = ord(char) - ord('A')
                
                # Avancer les rotors
                rotor_pos[0] = (rotor_pos[0] + 1) % 26
                if rotor_pos[0] == 0:
                    rotor_pos[1] = (rotor_pos[1] + 1) % 26
                    if rotor_pos[1] == 0:
                        rotor_pos[2] = (rotor_pos[2] + 1) % 26
                
                # Passage √† travers les rotors (de droite √† gauche)
                idx = (idx + rotor_pos[0]) % 26
                idx = ord(rotor_wirings[rotors[0]][idx]) - ord('A')
                
                idx = (idx - rotor_pos[0] + rotor_pos[1]) % 26
                idx = ord(rotor_wirings[rotors[1]][idx]) - ord('A')
                
                idx = (idx - rotor_pos[1] + rotor_pos[2]) % 26
                idx = ord(rotor_wirings[rotors[2]][idx]) - ord('A')
                
                idx = (idx - rotor_pos[2]) % 26
                
                # R√©flecteur
                idx = ord(reflectors[reflector][idx]) - ord('A')
                idx = (idx + rotor_pos[2]) % 26
                
                # Retour √† travers les rotors (de gauche √† droite)
                idx = rotor_wirings[rotors[2]].index(chr(idx + ord('A')))
                idx = (idx + rotor_pos[1] - rotor_pos[2]) % 26
                
                idx = rotor_wirings[rotors[1]].index(chr(idx + ord('A')))
                idx = (idx + rotor_pos[0] - rotor_pos[1]) % 26
                
                idx = rotor_wirings[rotors[0]].index(chr(idx + ord('A')))
                idx = (idx - rotor_pos[0]) % 26
                
                result.append(chr(idx + ord('A')))
            else:
                result.append(char)
        
        return ''.join(result)
    
    # ====================================================
    # üîê ALGORITHMES SYM√âTRIQUES MODERNES
    # ====================================================
    
    def aes_encrypt(self, text, password=None):
        """AES-256-GCM (authentifi√©)"""
        if password is None:
            password = input("üîë Mot de passe AES: ").strip()
        
        salt = get_random_bytes(16)
        key = PBKDF2(password, salt, dkLen=32, count=100000)
        
        cipher = AES.new(key, AES.MODE_GCM)
        ct_bytes, tag = cipher.encrypt_and_digest(text.encode('utf-8'))
        
        return json.dumps({
            'algorithm': 'AES-256-GCM',
            'ciphertext': base64.b64encode(ct_bytes).decode(),
            'iv': base64.b64encode(cipher.nonce).decode(),
            'salt': base64.b64encode(salt).decode(),
            'tag': base64.b64encode(tag).decode()
        }, indent=2)
    
    def aes_decrypt(self, data, password=None):
        """D√©chiffrement AES"""
        if password is None:
            password = input("üîë Mot de passe AES: ").strip()
        
        try:
            data_dict = json.loads(data)
            
            ct = base64.b64decode(data_dict['ciphertext'])
            iv = base64.b64decode(data_dict['iv'])
            salt = base64.b64decode(data_dict['salt'])
            tag = base64.b64decode(data_dict['tag'])
            
            key = PBKDF2(password, salt, dkLen=32, count=100000)
            cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
            pt = cipher.decrypt_and_verify(ct, tag)
            
            return pt.decode('utf-8')
        except Exception as e:
            return f"‚ùå Erreur: {str(e)}"
    
    def chacha20_encrypt(self, text, password=None):
        """ChaCha20 (optimis√© pour ARM/Raspberry Pi)"""
        if password is None:
            password = input("üîë Mot de passe ChaCha20: ").strip()
        
        salt = get_random_bytes(16)
        key = scrypt(password, salt, key_len=32, N=2**14, r=8, p=1)
        
        cipher = ChaCha20.new(key=key)
        ct_bytes = cipher.encrypt(text.encode('utf-8'))
        
        return json.dumps({
            'algorithm': 'ChaCha20',
            'ciphertext': base64.b64encode(ct_bytes).decode(),
            'nonce': base64.b64encode(cipher.nonce).decode(),
            'salt': base64.b64encode(salt).decode()
        }, indent=2)
    
    def chacha20_decrypt(self, data, password=None):
        """D√©chiffrement ChaCha20"""
        if password is None:
            password = input("üîë Mot de passe ChaCha20: ").strip()
        
        try:
            data_dict = json.loads(data)
            
            ct = base64.b64decode(data_dict['ciphertext'])
            nonce = base64.b64decode(data_dict['nonce'])
            salt = base64.b64decode(data_dict['salt'])
            
            key = scrypt(password, salt, key_len=32, N=2**14, r=8, p=1)
            cipher = ChaCha20.new(key=key, nonce=nonce)
            pt = cipher.decrypt(ct)
            
            return pt.decode('utf-8')
        except Exception as e:
            return f"‚ùå Erreur: {str(e)}"
    
    # ====================================================
    # üîë ALGORITHMES ASYM√âTRIQUES
    # ====================================================
    
    def rsa_generate_keys(self, key_size=2048):
        """G√©n√®re une paire de cl√©s RSA"""
        print(f"‚è≥ G√©n√©ration cl√©s RSA-{key_size} (peut prendre quelques secondes)...")
        
        key = RSA.generate(key_size)
        self.rsa_keys['private'] = key.export_key().decode('utf-8')
        self.rsa_keys['public'] = key.publickey().export_key().decode('utf-8')
        
        return {
            'algorithm': f'RSA-{key_size}',
            'private_key_preview': self.rsa_keys['private'][:100] + "...",
            'public_key_preview': self.rsa_keys['public'][:100] + "...",
            'private_key_file': 'rsa_private.pem',
            'public_key_file': 'rsa_public.pem'
        }
    
    def rsa_encrypt(self, text, public_key=None):
        """Chiffrement RSA"""
        if public_key is None:
            if 'public' not in self.rsa_keys:
                return "‚ùå Aucune cl√© publique disponible. G√©n√©rer d'abord avec 'rsa generate'"
            public_key = self.rsa_keys['public']
        
        try:
            key = RSA.import_key(public_key)
            cipher = PKCS1_OAEP.new(key)
            
            # RSA a une limite de taille, on doit segmenter pour les longs textes
            max_length = key.size_in_bytes() - 42  # Pour PKCS1_OAEP
            
            if len(text.encode('utf-8')) > max_length:
                return f"‚ùå Texte trop long pour RSA. Maximum: {max_length} bytes"
            
            ct_bytes = cipher.encrypt(text.encode('utf-8'))
            
            return {
                'algorithm': 'RSA-OAEP',
                'ciphertext': base64.b64encode(ct_bytes).decode(),
                'key_size': key.size_in_bits()
            }
        except Exception as e:
            return f"‚ùå Erreur: {str(e)}"
    
    def rsa_decrypt(self, ciphertext, private_key=None):
        """D√©chiffrement RSA"""
        if private_key is None:
            if 'private' not in self.rsa_keys:
                return "‚ùå Aucune cl√© priv√©e disponible"
            private_key = self.rsa_keys['private']
        
        try:
            key = RSA.import_key(private_key)
            cipher = PKCS1_OAEP.new(key)
            
            ct = base64.b64decode(ciphertext)
            pt = cipher.decrypt(ct)
            
            return pt.decode('utf-8')
        except Exception as e:
            return f"‚ùå Erreur: {str(e)}"
    
    def rsa_sign(self, message, private_key=None):
        """Signature RSA"""
        if private_key is None:
            if 'private' not in self.rsa_keys:
                return "‚ùå Aucune cl√© priv√©e disponible"
            private_key = self.rsa_keys['private']
        
        try:
            key = RSA.import_key(private_key)
            h = SHA256.new(message.encode('utf-8'))
            signature = pkcs1_15.new(key).sign(h)
            
            return {
                'algorithm': 'RSA-PKCS1.5-SHA256',
                'signature': base64.b64encode(signature).decode(),
                'message_hash': h.hexdigest()
            }
        except Exception as e:
            return f"‚ùå Erreur: {str(e)}"
    
    def rsa_verify(self, message, signature, public_key=None):
        """V√©rification signature RSA"""
        if public_key is None:
            if 'public' not in self.rsa_keys:
                return "‚ùå Aucune cl√© publique disponible"
            public_key = self.rsa_keys['public']
        
        try:
            key = RSA.import_key(public_key)
            h = SHA256.new(message.encode('utf-8'))
            sig = base64.b64decode(signature)
            pkcs1_15.new(key).verify(h, sig)
            return "‚úÖ Signature valide"
        except (ValueError, TypeError) as e:
            return f"‚ùå Signature invalide: {str(e)}"
    
    # ====================================================
    # üìú HACHAGE
    # ====================================================
    
    def sha256_hash(self, text):
        """Calcule le hash SHA-256"""
        # Hash simple
        simple_hash = hashlib.sha256(text.encode('utf-8')).hexdigest()
        
        # Hash avec sel (pour les mots de passe)
        salt = get_random_bytes(16).hex()
        salted_hash = hashlib.sha256((text + salt).encode('utf-8')).hexdigest()
        
        return {
            'algorithm': 'SHA-256',
            'hash': simple_hash,
            'salted_hash': salted_hash,
            'salt': salt,
            'length': len(simple_hash)
        }
    
    def verify_hash(self, text, hash_to_verify):
        """V√©rifie un hash SHA-256"""
        computed_hash = hashlib.sha256(text.encode('utf-8')).hexdigest()
        
        if computed_hash == hash_to_verify:
            return "‚úÖ Hash valide"
        else:
            return f"‚ùå Hash invalide. Comput√©: {computed_hash[:16]}..."
    
    # ====================================================
    # üéÆ INTERFACE UTILISATEUR
    # ====================================================
    
    def show_menu(self):
        """Affiche le menu principal"""
        menu = """
üîê CRYPTOBOT PRO - MENU PRINCIPAL:

üèõÔ∏è  CLASSIQUE:
  1. Vigen√®re (chiffrer)
  2. Vigen√®re (d√©chiffrer)
  3. C√©sar (chiffrer)
  4. C√©sar (d√©chiffrer)
  5. Enigma

üîê SYM√âTRIQUE MODERNE:
  6. AES-256-GCM (chiffrer)
  7. AES-256-GCM (d√©chiffrer)
  8. ChaCha20 (chiffrer) - Optimis√© RPi
  9. ChaCha20 (d√©chiffrer)

üîë ASYM√âTRIQUE:
  10. RSA (g√©n√©rer cl√©s)
  11. RSA (chiffrer)
  12. RSA (d√©chiffrer)
  13. RSA (signer)
  14. RSA (v√©rifier signature)

üìú HACHAGE:
  15. SHA-256 (calculer hash)
  16. SHA-256 (v√©rifier hash)

üîß UTILITAIRES:
  17. Afficher cl√©s RSA
  18. Sauver cl√©s dans fichiers
  19. Aide / Info algorithmes
  20. Quitter

Choisis une option (1-20):
"""
        print(menu)
    
    def show_algorithm_info(self):
        """Informations sur les algorithmes"""
        info = """
üìö INFORMATIONS SUR LES ALGORITHMES:

üèõÔ∏è  CLASSIQUE:
  ‚Ä¢ Vigen√®re (16e si√®cle): Chiffrement polyalphab√©tique avec cl√©
  ‚Ä¢ C√©sar (Jules C√©sar): Simple d√©calage de lettres
  ‚Ä¢ Enigma (WW2): Machine de chiffrement allemande

üîê SYM√âTRIQUE MODERNE:
  ‚Ä¢ AES-256-GCM: Standard actuel, authentifi√©, rapide
  ‚Ä¢ ChaCha20: Alternative √† AES, optimis√© pour ARM (Raspberry Pi)

üîë ASYM√âTRIQUE:
  ‚Ä¢ RSA: Cryptographie √† cl√© publique/publique
  ‚Ä¢ Permet chiffrement, signatures digitales

üìú HACHAGE:
  ‚Ä¢ SHA-256: Fonction de hachage cryptographique
  ‚Ä¢ Utilis√© pour: v√©rifier int√©grit√©, stocker mots de passe

üí° CONSEILS:
  ‚Ä¢ Pour fichiers: AES ou ChaCha20
  ‚Ä¢ Pour √©changes s√©curis√©s: RSA + AES
  ‚Ä¢ Pour mots de passe: SHA-256 avec sel
  ‚Ä¢ Pour Raspberry Pi: ChaCha20 est plus rapide
"""
        print(info)
    
    def save_keys_to_files(self):
        """Sauvegarde les cl√©s RSA dans des fichiers"""
        if 'private' not in self.rsa_keys:
            print("‚ùå Aucune cl√© RSA √† sauvegarder")
            return
        
        try:
            with open('rsa_private.pem', 'w') as f:
                f.write(self.rsa_keys['private'])
            
            with open('rsa_public.pem', 'w') as f:
                f.write(self.rsa_keys['public'])
            
            print("‚úÖ Cl√©s sauvegard√©es:")
            print("   ‚Ä¢ rsa_private.pem (GARDEZ SECRET!)")
            print("   ‚Ä¢ rsa_public.pem (peut √™tre partag√©)")
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde: {str(e)}")
    
    def run(self):
        """Boucle principale"""
        print("\nüöÄ CryptoBot Pro pr√™t!")
        
        while True:
            self.show_menu()
            
            try:
                choice = input("> ").strip()
                
                if choice == '20' or choice.lower() == 'quit':
                    print("üëã Au revoir!")
                    break
                
                # Vigen√®re
                elif choice == '1':
                    text = input("Texte √† chiffrer: ").strip()
                    key = input("Cl√© Vigen√®re: ").strip()
                    result = self.vigenere(text, key, 'encrypt')
                    print(f"üîê R√©sultat: {result}")
                
                elif choice == '2':
                    text = input("Texte √† d√©chiffrer: ").strip()
                    key = input("Cl√© Vigen√®re: ").strip()
                    result = self.vigenere(text, key, 'decrypt')
                    print(f"üîì R√©sultat: {result}")
                
                # C√©sar
                elif choice == '3':
                    text = input("Texte √† chiffrer: ").strip()
                    shift = int(input("D√©calage (0-25): ").strip())
                    result = self.caesar(text, shift, 'encrypt')
                    print(f"üîê R√©sultat: {result}")
                
                elif choice == '4':
                    text = input("Texte √† d√©chiffrer: ").strip()
                    shift = int(input("D√©calage (0-25): ").strip())
                    result = self.caesar(text, shift, 'decrypt')
                    print(f"üîì R√©sultat: {result}")
                
                # Enigma
                elif choice == '5':
                    text = input("Texte pour Enigma: ").strip()
                    result = self.enigma(text)
                    print(f"üîê R√©sultat Enigma: {result}")
                
                # AES
                elif choice == '6':
                    text = input("Texte √† chiffrer: ").strip()
                    result = self.aes_encrypt(text)
                    print(f"üîê AES (copier tout):\n{result}")
                
                elif choice == '7':
                    data = input("Donn√©es AES (JSON): ").strip()
                    result = self.aes_decrypt(data)
                    print(f"üîì R√©sultat: {result}")
                
                # ChaCha20
                elif choice == '8':
                    text = input("Texte √† chiffrer: ").strip()
                    result = self.chacha20_encrypt(text)
                    print(f"üîê ChaCha20 (copier tout):\n{result}")
                
                elif choice == '9':
                    data = input("Donn√©es ChaCha20 (JSON): ").strip()
                    result = self.chacha20_decrypt(data)
                    print(f"üîì R√©sultat: {result}")
                
                # RSA
                elif choice == '10':
                    try:
                        size = int(input("Taille cl√© (1024, 2048, 4096) [2048]: ") or "2048")
                        result = self.rsa_generate_keys(size)
                        print(f"üîë Cl√©s g√©n√©r√©es:")
                        for key, value in result.items():
                            print(f"  {key}: {value}")
                    except ValueError:
                        print("‚ùå Taille invalide")
                
                elif choice == '11':
                    if 'public' not in self.rsa_keys:
                        print("‚ùå G√©n√©rer d'abord des cl√©s RSA (option 10)")
                        continue
                    text = input("Texte √† chiffrer: ").strip()
                    result = self.rsa_encrypt(text)
                    if isinstance(result, dict):
                        print(f"üîê RSA chiffr√©:")
                        for key, value in result.items():
                            print(f"  {key}: {value}")
                    else:
                        print(result)
                
                elif choice == '12':
                    if 'private' not in self.rsa_keys:
                        print("‚ùå G√©n√©rer d'abord des cl√©s RSA (option 10)")
                        continue
                    text = input("Texte chiffr√© (base64): ").strip()
                    result = self.rsa_decrypt(text)
                    print(f"üîì R√©sultat: {result}")
                
                elif choice == '13':
                    if 'private' not in self.rsa_keys:
                        print("‚ùå G√©n√©rer d'abord des cl√©s RSA (option 10)")
                        continue
                    message = input("Message √† signer: ").strip()
                    result = self.rsa_sign(message)
                    if isinstance(result, dict):
                        print(f"‚úçÔ∏è  Signature RSA:")
                        for key, value in result.items():
                            print(f"  {key}: {value}")
                    else:
                        print(result)
                
                elif choice == '14':
                    if 'public' not in self.rsa_keys:
                        print("‚ùå G√©n√©rer d'abord des cl√©s RSA (option 10)")
                        continue
                    message = input("Message original: ").strip()
                    signature = input("Signature (base64): ").strip()
                    result = self.rsa_verify(message, signature)
                    print(f"üîç {result}")
                
                # SHA-256
                elif choice == '15':
                    text = input("Texte √† hacher: ").strip()
                    result = self.sha256_hash(text)
                    print(f"üìú Hash SHA-256:")
                    for key, value in result.items():
                        print(f"  {key}: {value}")
                
                elif choice == '16':
                    text = input("Texte original: ").strip()
                    hash_val = input("Hash √† v√©rifier: ").strip()
                    result = self.verify_hash(text, hash_val)
                    print(result)
                
                # Utilitaires
                elif choice == '17':
                    if self.rsa_keys:
                        print("üîë Cl√©s RSA en m√©moire:")
                        for key_type, key_value in self.rsa_keys.items():
                            print(f"\n{key_type}:")
                            print(key_value[:200] + "..." if len(key_value) > 200 else key_value)
                    else:
                        print("üì≠ Aucune cl√© RSA en m√©moire")
                
                elif choice == '18':
                    self.save_keys_to_files()
                
                elif choice == '19':
                    self.show_algorithm_info()
                
                else:
                    print("‚ùå Option invalide")
                
                input("\n‚Üµ Appuyez sur Entr√©e pour continuer...")
                
            except KeyboardInterrupt:
                print("\n\nüëã Interrompu")
                break
            except Exception as e:
                print(f"‚ö†Ô∏è  Erreur: {str(e)}")
                input("\n‚Üµ Appuyez sur Entr√©e pour continuer...")

def main():
    """Point d'entr√©e"""
    try:
        from Crypto.Cipher import AES
        from Crypto.PublicKey import RSA
        bot = CryptoBotPro()
        bot.run()
    except ImportError:
        print("‚ùå pycryptodome manquant!")
        print("üëâ source cryptobot_env/bin/activate")
        print("üëâ pip install pycryptodome")

if __name__ == "__main__":
    main()
EOF